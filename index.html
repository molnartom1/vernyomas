<!doctype html>
<html lang="hu">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Vérnyomásnapló</title>

  <!-- Supabase JS (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <style>
    :root{
      --card:rgba(255,255,255,.06);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.68);
      --border:rgba(255,255,255,.12);
      --shadow:0 18px 55px rgba(0,0,0,.35);
      --accent:#6ee7ff;   /* SYS */
      --accent2:#a78bfa;  /* DIA */
      --accent3:#3ee6a0;  /* Pulse */
      --warn:#ffcc66;     /* Zone */
      --danger:#ff6b6b;
      --radius:18px;
      --radius2:14px;
      --font:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--font);
      color:var(--text);
      background:
        radial-gradient(1200px 600px at 20% 10%, rgba(110,231,255,.18), transparent 60%),
        radial-gradient(900px 500px at 80% 0%, rgba(167,139,250,.16), transparent 55%),
        radial-gradient(900px 600px at 60% 90%, rgba(62,230,160,.10), transparent 55%),
        linear-gradient(180deg, #070b14 0%, #0b1220 100%);
      min-height:100vh;
    }
    .wrap{max-width:1100px;margin:0 auto;padding:24px 16px 60px;}
    header{
      display:flex;gap:16px;align-items:flex-start;justify-content:space-between;
      flex-wrap:wrap;margin-bottom:18px;
    }
    h1{margin:0;font-size:clamp(22px,2.6vw,34px);letter-spacing:.2px;}

    .pill{
      font-size:12px;padding:6px 10px;border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      color:var(--muted);background:rgba(255,255,255,.04);
      display:inline-flex;align-items:center;gap:8px;user-select:none;
    }
    .dot{
      width:8px;height:8px;border-radius:999px;
      background:linear-gradient(90deg,var(--accent),var(--accent2));
      box-shadow:0 0 0 3px rgba(110,231,255,.15);
    }

    .grid{display:grid;grid-template-columns:1.1fr .9fr;gap:16px;align-items:start;}
    @media (max-width:920px){.grid{grid-template-columns:1fr;}}

    .card{
      background:linear-gradient(180deg,var(--card) 0%, rgba(255,255,255,.05) 100%);
      border:1px solid var(--border);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .card .hd{
      padding:16px 16px 12px;
      border-bottom:1px solid rgba(255,255,255,.10);
      display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;
    }
    .card .hd h2{margin:0;font-size:16px;letter-spacing:.2px;}
    .bd{padding:16px;}

    .form{display:grid;grid-template-columns:1fr 1fr;gap:12px;}
    @media (max-width:520px){.form{grid-template-columns:1fr;}}

    label{display:flex;flex-direction:column;gap:6px;font-size:12px;color:var(--muted);}

    input,textarea,select{
      width:100%;
      padding:11px 12px;
      border-radius:var(--radius2);
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.18);
      color:var(--text);
      outline:none;
      font-size:14px;
    }
    /* iOS zoom fix: 16px minimum font-size on inputs */
    @media (max-width: 640px){
      input,textarea,select{ font-size:16px; }
    }
    input:focus,textarea:focus,select:focus{
      border-color:rgba(110,231,255,.55);
      box-shadow:0 0 0 4px rgba(110,231,255,.12);
    }
    textarea{resize:vertical;min-height:42px;}
    .span2{grid-column:1/-1;}

    .actions{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-top:10px;}
    button{
      border:0;cursor:pointer;
      padding:11px 14px;
      border-radius:14px;
      font-weight:650;
      letter-spacing:.2px;
      color:#08101d;
      background:linear-gradient(90deg,var(--accent),var(--accent2));
      box-shadow:0 12px 30px rgba(110,231,255,.12);
      transition:transform .08s ease,filter .2s ease;
      white-space:nowrap;
    }
    button:hover{filter:brightness(1.05);}
    button:active{transform:translateY(1px);}
    button:disabled{opacity:.5;cursor:not-allowed;transform:none;filter:none;}
    .btn-ghost{
      background:rgba(255,255,255,.06);
      color:var(--text);
      border:1px solid rgba(255,255,255,.14);
      box-shadow:none;
      font-weight:600;
    }
    .btn-danger{
      background:rgba(255,107,107,.12);
      color:#ffd0d0;
      border:1px solid rgba(255,107,107,.25);
      box-shadow:none;
      font-weight:800;
    }
    .btn-ok{
      background:rgba(62,230,160,.12);
      color:#cbffe9;
      border:1px solid rgba(62,230,160,.22);
      box-shadow:none;
      font-weight:800;
    }
    .btn-warn{
      background:rgba(255,204,102,.12);
      color:#ffe6b3;
      border:1px solid rgba(255,204,102,.22);
      box-shadow:none;
      font-weight:800;
    }

    .stats{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;}
    @media (max-width:520px){.stats{grid-template-columns:1fr;}}
    .stat{
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.10);
      border-radius:var(--radius2);
      padding:12px;
    }
    .stat .k{color:var(--muted);font-size:12px;}
    .stat .v{font-size:18px;margin-top:6px;font-weight:800;letter-spacing:.2px;}
    .stat small{color:var(--muted);font-weight:600;}

    .toolbar{
      display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;
      margin:10px 0 10px;
    }
    .toolbar .left,.toolbar .right{display:flex;gap:10px;flex-wrap:wrap;align-items:center;}
    .mini{font-size:12px;color:var(--muted);}

    .pageSize{
      display:inline-flex;align-items:center;gap:8px;
      padding:8px 10px;border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.18);
      color:var(--muted);
      font-size:12px;
      white-space:nowrap;
    }
    .pageSize select{
      padding:8px 10px;
      border-radius:999px;
      width:auto;
      font-size:12px;
    }

    .rangeCustom{
      display:none;
      align-items:center;
      gap:8px;
      padding:8px 10px;border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.18);
      color:var(--muted);
      font-size:12px;
      white-space:nowrap;
    }
    .rangeCustom input{
      width:90px;
      padding:8px 10px;
      border-radius:999px;
      font-size:12px;
    }

    .pager{
      display:flex; gap:8px; align-items:center; flex-wrap:wrap;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.18);
    }
    .pager .pbtn{
      padding:8px 10px;
      border-radius:999px;
      background:rgba(255,255,255,.06);
      color:var(--text);
      border:1px solid rgba(255,255,255,.12);
      box-shadow:none;
      font-weight:800;
      min-width:38px;
    }
    .pager .pbtn:hover{ filter:brightness(1.05); }
    .pager .pbtn:disabled{ opacity:.45; cursor:not-allowed; filter:none; }
    .pager .pbtn.active{
      background:linear-gradient(90deg, rgba(110,231,255,.25), rgba(167,139,250,.20));
      border-color:rgba(110,231,255,.35);
    }
    .pager .dots{ color:rgba(255,255,255,.35); padding:0 2px; font-weight:800; }

    .chartCard{
      margin-top:10px;
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.10);
      border-radius:var(--radius);
      padding:12px;
      position:relative;
    }
    .chartTop{
      display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;
      margin-bottom:10px;
    }
    .legend{display:flex;gap:10px;flex-wrap:wrap;align-items:center;}
    .lg{
      display:inline-flex;align-items:center;gap:8px;
      padding:6px 10px;border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.18);
      color:var(--muted);
      font-size:12px;user-select:none;
    }
    .swatch{width:10px;height:10px;border-radius:999px;background:#fff;opacity:.9;}

    .chartControls{
      display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;
      margin-bottom:10px;
    }
    .toggles{display:flex;gap:10px;flex-wrap:wrap;align-items:center;}
    .chk{
      display:inline-flex;align-items:center;gap:8px;
      padding:8px 10px;border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.18);
      color:var(--muted);
      font-size:12px;user-select:none;
    }
    .chk input{width:auto;padding:0;margin:0;box-shadow:none;}

    .zones{
      display:flex;gap:8px;flex-wrap:wrap;align-items:center;
      color:var(--muted);font-size:12px;
    }
    .zones input{
      width:86px;
      padding:9px 10px;
      border-radius:999px;
    }

    .canvasWrap{position:relative;}
    canvas{
      width:100%;
      height:300px;
      display:block;
      border-radius:14px;
      background:rgba(0,0,0,.16);
      border:1px solid rgba(255,255,255,.10);
      touch-action:none;
    }

    .legendBelow{
      margin-top:10px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-start;
      color:var(--muted);
      font-size:12px;
    }
    .legendBelow .it{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:7px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.18);
      user-select:none;
    }
    .legendBelow .sq{
      width:12px;height:12px;border-radius:4px;
      border:1px solid rgba(255,255,255,.25);
    }

    .tooltip{
      position:absolute;
      padding:10px 10px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.55);
      backdrop-filter:blur(8px);
      color:var(--text);
      box-shadow:0 14px 40px rgba(0,0,0,.35);
      font-size:12px;
      line-height:1.35;
      display:none;
      pointer-events:none;
      max-width:320px;
      white-space:nowrap;
      z-index:5;
    }
    .tooltip .t{color:rgba(255,255,255,.75);margin-bottom:6px;}
    .tooltip .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;}
    .tooltip .b{
      display:inline-flex;align-items:center;gap:8px;
      padding:6px 10px;border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.18);
      font-weight:800;
    }
    .tooltip .b .s{width:8px;height:8px;border-radius:999px;background:#fff;opacity:.95;}

    .list{display:flex;flex-direction:column;gap:10px;margin-top:10px;}
    .item{
      background:rgba(255,255,255,.05);
      border:1px solid rgba(255,255,255,.10);
      border-radius:var(--radius);
      padding:12px;
      display:flex;gap:12px;justify-content:space-between;align-items:flex-start;
    }
    .item .l{display:flex;flex-direction:column;gap:8px;min-width:0;}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;}
    .badge{
      font-size:12px;padding:6px 10px;border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.18);
      color:var(--text);
      font-weight:800;
      display:inline-flex;gap:8px;align-items:center;user-select:none;
    }
    .tag{
      font-size:12px;padding:5px 10px;border-radius:999px;
      color:var(--muted);
      border:1px dashed rgba(255,255,255,.20);
      background:rgba(255,255,255,.03);
      user-select:none;
    }
    .alertTag{
      font-size:12px;padding:5px 10px;border-radius:999px;
      color:#ffe0e0;
      border:1px solid rgba(255,107,107,.35);
      background:rgba(255,107,107,.10);
      font-weight:900;
      user-select:none;
      display:inline-flex;align-items:center;gap:6px;
    }
    .note{
      color:var(--muted);
      font-size:13px;
      line-height:1.35;
      white-space:pre-wrap;
      word-break:break-word;
    }
    .item .r{display:flex;flex-direction:column;gap:8px;align-items:flex-end;flex-shrink:0;}
    .iconbtn{
      padding:9px 11px;
      border-radius:12px;
      background:rgba(255,255,255,.06);
      color:var(--text);
      border:1px solid rgba(255,255,255,.12);
      font-weight:800;
    }
    .iconbtn:hover{filter:brightness(1.05);}
    .iconbtn.d{
      background:rgba(255,107,107,.10);
      border-color:rgba(255,107,107,.22);
      color:#ffd0d0;
    }

    .empty{
      padding:18px;
      border-radius:var(--radius);
      border:1px dashed rgba(255,255,255,.20);
      color:var(--muted);
      background:rgba(255,255,255,.03);
      line-height:1.45;
      margin-top:10px;
    }

    .toast{
      position:fixed;
      left:50%;
      bottom:18px;
      transform:translateX(-50%);
      background:rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.14);
      backdrop-filter:blur(8px);
      padding:10px 12px;
      border-radius:999px;
      color:var(--text);
      display:none;
      z-index:50;
      box-shadow:0 14px 40px rgba(0,0,0,.35);
      font-size:13px;
      font-weight:700;
    }

    .risk-ok{border-color:rgba(62,230,160,.28);}
    .risk-ok .badge{border-color:rgba(62,230,160,.35);}
    .risk-warn{border-color:rgba(255,204,102,.28);}
    .risk-warn .badge{border-color:rgba(255,204,102,.35);}
    .risk-high{border-color:rgba(255,107,107,.30);}
    .risk-high .badge{border-color:rgba(255,107,107,.40);}

    /* Sync panel */
    .syncMini{
      margin-top:10px;
      padding:12px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.16);
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
    }
    .syncMini .left{display:flex;gap:10px;flex-wrap:wrap;align-items:center;}
    .syncState{
      font-size:12px;
      color:var(--muted);
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:7px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.04);
      user-select:none;
    }
    .syncDot{
      width:8px;height:8px;border-radius:999px;background:#999;
      box-shadow:0 0 0 3px rgba(255,255,255,.06);
    }
    .syncDot.ok{ background: rgba(62,230,160,.95); box-shadow:0 0 0 3px rgba(62,230,160,.18); }
    .syncDot.bad{ background: rgba(255,107,107,.95); box-shadow:0 0 0 3px rgba(255,107,107,.18); }
    .syncDot.mid{ background: rgba(255,204,102,.95); box-shadow:0 0 0 3px rgba(255,204,102,.18); }

    /* PRINT / PDF (A4) */
    #printArea{display:none;}
    @media print{
      @page{ size:A4; margin:12mm; }
      body{ background:#fff !important; color:#000 !important; -webkit-print-color-adjust:exact; print-color-adjust:exact; }
      .wrap, header, .grid, .card, .toast{ display:none !important; }
      #printArea{ display:block !important; }
    }
    .printDoc{ font-family:var(--font); color:#000; }
    .printHead{ display:flex; justify-content:space-between; align-items:flex-start; gap:16px; margin-bottom:10px; }
    .printHead h2{ margin:0; font-size:18px; }
    .printMeta{ font-size:12px; line-height:1.35; color:#222; white-space:nowrap; }
    .printStats{ display:flex; gap:10px; flex-wrap:wrap; margin:10px 0 10px; font-size:12px; }
    .pBox{ border:1px solid #bbb; border-radius:8px; padding:8px 10px; min-width:140px; }
    .pBox b{ font-size:14px; }
    .printChartBox{
      border:1px solid #bbb;
      border-radius:10px;
      padding:8px;
      margin:8px 0 12px;
    }
    .printChartBox img{ width:100%; height:auto; display:block; }
    .printTable{ width:100%; border-collapse:collapse; font-size:11px; }
    .printTable th,.printTable td{ border:1px solid #bbb; padding:6px 6px; vertical-align:top; }
    .printTable th{ background:#f3f3f3; text-align:left; }
    .mutedPrint{ color:#555; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Vérnyomásnapló</h1>
      <div class="pill"><span class="dot"></span> Online (helyi tárolás + felhő szinkron)</div>
    </header>

    <div class="grid">
      <!-- LEFT -->
      <section class="card">
        <div class="hd">
          <h2 id="formTitle">Új mérés rögzítése</h2>
          <span class="mini" id="countLabel">0 bejegyzés</span>
        </div>
        <div class="bd">
          <form id="bpForm" class="form" autocomplete="off">
            <label>
              Dátum és idő
              <input type="datetime-local" id="dt" required />
            </label>

            <label>
              Mérési helyzet
              <select id="context">
                <option value="Ülve">Ülve</option>
                <option value="Fekve">Fekve</option>
                <option value="Állva">Állva</option>
                <option value="Terhelés után">Terhelés után</option>
              </select>
            </label>

            <label>
              Szisztolés (SYS) mmHg
              <input type="number" id="sys" min="60" max="260" inputmode="numeric" required placeholder="pl. 125" />
            </label>

            <label>
              Diasztolés (DIA) mmHg
              <input type="number" id="dia" min="40" max="160" inputmode="numeric" required placeholder="pl. 80" />
            </label>

            <label>
              Pulzus (BPM)
              <input type="number" id="pulse" min="30" max="220" inputmode="numeric" placeholder="pl. 72" />
            </label>

            <label>
              Kar
              <select id="arm">
                <option value="Bal">Bal</option>
                <option value="Jobb">Jobb</option>
              </select>
            </label>

            <label class="span2">
              Megjegyzés (opcionális)
              <textarea id="note" placeholder="pl. reggel, kávé előtt, fejfájás..."></textarea>
            </label>

            <div class="span2 actions">
              <button type="submit" id="saveBtn">Mentés</button>
              <button type="button" class="btn-ghost" id="cancelEditBtn" style="display:none;">Mégse</button>

              <button type="button" class="btn-ghost" id="fillNow">Mostani idő</button>
              <button type="button" class="btn-ok" id="quickMorning">Reggel (07:00)</button>
              <button type="button" class="btn-warn" id="quickEvening">Este (19:00)</button>

              <button type="button" class="btn-ghost" id="exportJsonBtn">Export (JSON)</button>
              <button type="button" class="btn-ghost" id="exportCsvAllBtn">CSV export (összes)</button>
              <button type="button" class="btn-ghost" id="exportCsvFilteredBtn">CSV export (szűrt)</button>

              <label class="btn-ghost" style="display:inline-flex;align-items:center;gap:8px;cursor:pointer;">
                Import (JSON)
                <input type="file" id="importFile" accept="application/json" style="display:none">
              </label>

              <button type="button" class="btn-danger" id="clearAll">Összes törlése</button>
            </div>

            <!-- Felhő szinkron panel -->
            <div class="span2 syncMini">
              <div class="left">
                <span class="syncState" id="syncState">
                  <span class="syncDot" id="syncDot"></span>
                  <span id="syncText">Felhő szinkron: kikapcsolva</span>
                </span>
                <span class="mini" id="syncMeta">—</span>
              </div>
              <div class="right" style="display:flex;gap:10px;flex-wrap:wrap;align-items:center;">
                <button type="button" class="btn-ghost" id="syncSettingsBtn">Felhő beállítás</button>
                <button type="button" class="btn-ghost" id="syncNowBtn">Szinkron most</button>
              </div>
            </div>

          </form>
        </div>
      </section>

      <!-- RIGHT -->
      <section class="card">
        <div class="hd">
          <h2>Áttekintés & bejegyzések</h2>
          <span class="pill"><span class="dot"></span> Átlagok + Trend</span>
        </div>
        <div class="bd">
          <div class="stats">
            <div class="stat">
              <div class="k">Átlag SYS</div>
              <div class="v" id="avgSys">–</div>
              <small class="mini">mmHg</small>
            </div>
            <div class="stat">
              <div class="k">Átlag DIA</div>
              <div class="v" id="avgDia">–</div>
              <small class="mini">mmHg</small>
            </div>
            <div class="stat">
              <div class="k">Átlag pulzus</div>
              <div class="v" id="avgPulse">–</div>
              <small class="mini">BPM</small>
            </div>
          </div>

          <div class="toolbar">
            <div class="left">
              <input id="search" type="text" placeholder="Keresés megjegyzésben (pl. reggel, kávé)..." />

              <select id="range" title="Időszűrés">
                <option value="all">Összes</option>
                <option value="7">Utolsó 7 nap</option>
                <option value="30">Utolsó 30 nap</option>
                <option value="custom">Egyéni (napok)</option>
              </select>

              <div class="rangeCustom" id="rangeCustomWrap" title="Adj meg egyedi nap számot (pl. 14)">
                Napok:
                <input type="number" id="rangeCustomDays" min="1" max="3650" step="1" value="14" />
              </div>

              <button type="button" class="btn-ghost" id="toggleChart">Grafikon elrejt</button>
            </div>

            <div class="right">
              <span class="mini" id="filteredLabel">–</span>

              <div class="pageSize" title="Hány tétel látszódjon egy oldalon">
                Oldalméret:
                <select id="pageSize">
                  <option value="5">5</option>
                  <option value="10">10</option>
                  <option value="20">20</option>
                  <option value="all">Összes</option>
                </select>
              </div>

              <div class="pager" id="pager" style="display:none;"></div>

              <button type="button" class="btn-ghost" id="printBtn">Nyomtatás / PDF (A4)</button>
              <button type="button" class="btn-ghost" id="seedDemo">Demo adatok</button>
            </div>
          </div>

          <div class="chartCard" id="chartWrap">
            <div class="chartTop">
              <div class="legend">
                <span class="lg"><span class="swatch" id="swSys"></span> SYS</span>
                <span class="lg"><span class="swatch" id="swDia"></span> DIA</span>
                <span class="lg"><span class="swatch" id="swPulse"></span> Pulzus</span>
                <span class="lg"><span class="swatch" id="swZone"></span> Célzóna</span>
              </div>
              <span class="mini" id="chartHint">Szűrés alapján frissül</span>
            </div>

            <div class="chartControls">
              <div class="toggles">
                <label class="chk"><input type="checkbox" id="showPulse" checked> Pulzus-vonal</label>
                <label class="chk"><input type="checkbox" id="showZone" checked> Célzóna</label>
                <label class="chk"><input type="checkbox" id="snapNearest" checked> Tooltip “legközelebbi”</label>
              </div>

              <div class="zones" title="Célzóna (SYS és DIA tartomány)">
                <span class="mini">Cél SYS</span>
                <input type="number" id="zoneSysLo" min="60" max="260" step="1" value="110" />
                <input type="number" id="zoneSysHi" min="60" max="260" step="1" value="130" />
                <span class="mini">Cél DIA</span>
                <input type="number" id="zoneDiaLo" min="40" max="160" step="1" value="70" />
                <input type="number" id="zoneDiaHi" min="40" max="160" step="1" value="85" />
              </div>
            </div>

            <div class="canvasWrap">
              <canvas id="chart" width="1200" height="560"></canvas>
              <div class="tooltip" id="tooltip"></div>
            </div>

            <div class="legendBelow" aria-label="Színmagyarázat">
              <span class="it"><span class="sq" style="background:rgba(110,231,255,.95)"></span> SYS (mmHg)</span>
              <span class="it"><span class="sq" style="background:rgba(167,139,250,.95)"></span> DIA (mmHg)</span>
              <span class="it"><span class="sq" style="background:rgba(62,230,160,.95)"></span> Pulzus (BPM)</span>
              <span class="it"><span class="sq" style="background:rgba(255,204,102,.45)"></span> Célzóna</span>
            </div>
          </div>

          <div class="list" id="list"></div>
          <div class="empty" id="empty" style="display:none;">
            Még nincs bejegyzésed. Adj hozzá egy mérést bal oldalt.
          </div>
        </div>
      </section>
    </div>
  </div>

  <div id="printArea"></div>
  <div class="toast" id="toast"></div>

  <script>
    (function(){
      /******************************************************************
       * ✅ SUPABASE KONFIG – A TE ADATAIDDAL
       ******************************************************************/
      const SUPABASE_URL = "https://dtrqapdwautfchkdxcjm.supabase.co";
      const SUPABASE_ANON_KEY = "sb_publishable_MGvraq_UcNWcxb1euk5fyw_ekOl_k6y";
      const SUPABASE_TABLE = "bp_logs";

      /******************************************************************
       * Helyi kulcsok
       ******************************************************************/
      const STORAGE_KEY = "bp_log_v15";
      const PREF_KEY = "bp_chart_prefs_v11";
      const UI_KEY = "bp_ui_prefs_v10";
      const SYNC_KEY = "bp_cloud_sync_v2";

      /******************************************************************
       * UI elemek
       ******************************************************************/
      const $ = (id) => document.getElementById(id);

      const form = $("bpForm");
      const formTitle = $("formTitle");
      const saveBtn = $("saveBtn");
      const cancelEditBtn = $("cancelEditBtn");

      const dt = $("dt");
      const sys = $("sys");
      const dia = $("dia");
      const pulse = $("pulse");
      const note = $("note");
      const arm = $("arm");
      const context = $("context");

      const list = $("list");
      const empty = $("empty");
      const search = $("search");
      const range = $("range");
      const rangeCustomWrap = $("rangeCustomWrap");
      const rangeCustomDays = $("rangeCustomDays");

      const avgSys = $("avgSys");
      const avgDia = $("avgDia");
      const avgPulse = $("avgPulse");

      const countLabel = $("countLabel");
      const filteredLabel = $("filteredLabel");
      const toast = $("toast");

      const fillNowBtn = $("fillNow");
      const quickMorningBtn = $("quickMorning");
      const quickEveningBtn = $("quickEvening");

      const exportJsonBtn = $("exportJsonBtn");
      const exportCsvAllBtn = $("exportCsvAllBtn");
      const exportCsvFilteredBtn = $("exportCsvFilteredBtn");
      const importFile = $("importFile");
      const clearAllBtn = $("clearAll");
      const seedDemoBtn = $("seedDemo");
      const printBtn = $("printBtn");

      const pageSizeSel = $("pageSize");
      const pager = $("pager");

      const chartWrap = $("chartWrap");
      const toggleChartBtn = $("toggleChart");
      const chartCanvas = $("chart");
      const chartHint = $("chartHint");
      const tooltip = $("tooltip");

      const showPulseChk = $("showPulse");
      const showZoneChk = $("showZone");
      const snapNearestChk = $("snapNearest");

      const zoneSysLo = $("zoneSysLo");
      const zoneSysHi = $("zoneSysHi");
      const zoneDiaLo = $("zoneDiaLo");
      const zoneDiaHi = $("zoneDiaHi");

      const printArea = $("printArea");

      // Sync UI
      const syncSettingsBtn = $("syncSettingsBtn");
      const syncNowBtn = $("syncNowBtn");
      const syncDot = $("syncDot");
      const syncText = $("syncText");
      const syncMeta = $("syncMeta");

      $("swSys").style.background = "rgba(110,231,255,.95)";
      $("swDia").style.background = "rgba(167,139,250,.95)";
      $("swPulse").style.background = "rgba(62,230,160,.95)";
      $("swZone").style.background = "rgba(255,204,102,.70)";

      /******************************************************************
       * Állapot
       ******************************************************************/
      let entries = loadAny();
      let chartVisible = true;
      let editingId = null;

      let page = 1;
      let pageSize = 5;

      // chart hover state
      let chartState = null;

      // Sync
      let sb = null;
      let syncCfg = loadSyncCfg();
      let syncBusy = false;
      let syncDebounceT = null;
      let localRevision = Date.now();

      /******************************************************************
       * Init
       ******************************************************************/
      setNow();
      loadUiPrefs();
      loadChartPrefs();
      syncRangeCustomUI();

      initSupabase();
      updateSyncUI("init");

      // első render
      render();

      // startup pull, ha aktív
      (async () => {
        if (syncCfg.enabled && syncCfg.logId) {
          await cloudPull({reason:"startup"});
        }
      })();

      /******************************************************************
       * Események
       ******************************************************************/
      form.addEventListener("submit", (e) => {
        e.preventDefault();

        const sysV = toInt(sys.value);
        const diaV = toInt(dia.value);
        const pulseV = pulse.value.trim() ? toInt(pulse.value) : null;

        if(!dt.value) return showToast("Adj meg dátumot és időt.");
        if(!isFinite(sysV) || !isFinite(diaV)) return showToast("SYS és DIA kötelező.");
        if(sysV < 60 || sysV > 260 || diaV < 40 || diaV > 160) return showToast("Értékek határon kívül.");
        if(sysV <= diaV) return showToast("A SYS általában nagyobb, mint a DIA.");

        const item = {
          id: editingId ? editingId : cryptoRandomId(),
          ts: new Date(dt.value).toISOString(),
          sys: sysV,
          dia: diaV,
          pulse: (pulseV && isFinite(pulseV)) ? pulseV : null,
          note: note.value.trim(),
          arm: arm.value,
          context: context.value
        };

        if(editingId){
          const idx = entries.findIndex(x => x.id === editingId);
          if(idx >= 0){
            entries[idx] = item;
            entries.sort((a,b)=> new Date(b.ts) - new Date(a.ts));
            save(entries);
            markChangedAndMaybeSync();
            showToast("Módosítva ✔");
            exitEditMode();
            page = 1;
            render();
            return;
          }else{
            editingId = null;
          }
        }

        entries.unshift(item);
        save(entries);
        markChangedAndMaybeSync();

        note.value = "";
        showToast("Mentve ✔");
        page = 1;
        render();
      });

      cancelEditBtn.addEventListener("click", () => {
        exitEditMode();
        showToast("Szerkesztés megszakítva.");
      });

      fillNowBtn.addEventListener("click", () => setNow(true));

      quickMorningBtn.addEventListener("click", () => {
        setTimePreset(7, 0);
        if(!note.value.trim()) note.value = "Reggel";
        sys.focus();
        showToast("Reggeli idő ✔");
      });

      quickEveningBtn.addEventListener("click", () => {
        setTimePreset(19, 0);
        if(!note.value.trim()) note.value = "Este";
        sys.focus();
        showToast("Esti idő ✔");
      });

      search.addEventListener("input", () => { page = 1; render(); });

      range.addEventListener("change", () => {
        syncRangeCustomUI();
        page = 1;
        saveUiPrefs();
        render();
      });

      rangeCustomDays.addEventListener("input", () => {
        if(range.value !== "custom") return;
        page = 1;
        saveUiPrefs();
        render();
      });

      pageSizeSel.addEventListener("change", () => {
        const v = pageSizeSel.value;
        pageSize = (v === "all") ? Infinity : clampInt(toInt(v), 1, 9999);
        page = 1;
        saveUiPrefs();
        renderListOnly();
        renderPager(getFiltered().filtered.length);
      });

      [showPulseChk, showZoneChk, snapNearestChk, zoneSysLo, zoneSysHi, zoneDiaLo, zoneDiaHi].forEach(el=>{
        el.addEventListener("input", () => {
          persistChartPrefs();
          if(chartVisible) drawChart(getFiltered().filtered);
          markChangedAndMaybeSync();
        });
      });

      toggleChartBtn.addEventListener("click", () => {
        chartVisible = !chartVisible;
        chartWrap.style.display = chartVisible ? "block" : "none";
        toggleChartBtn.textContent = chartVisible ? "Grafikon elrejt" : "Grafikon mutat";
        if(chartVisible) drawChart(getFiltered().filtered);
        hideTooltip();
      });

      exportJsonBtn.addEventListener("click", () => {
        const data = buildExportObject();
        downloadBlob(JSON.stringify(data, null, 2), `vernyomasnaplo_export_${stamp()}.json`, "application/json");
        showToast("JSON export ✔");
      });

      exportCsvAllBtn.addEventListener("click", () => {
        const csv = buildCsv(entries);
        downloadBlob(csv, `vernyomasnaplo_${stamp()}_osszes.csv`, "text/csv;charset=utf-8");
        showToast("CSV export ✔");
      });

      exportCsvFilteredBtn.addEventListener("click", () => {
        const filtered = getFiltered().filtered;
        const csv = buildCsv(filtered);
        downloadBlob(csv, `vernyomasnaplo_${stamp()}_szurt.csv`, "text/csv;charset=utf-8");
        showToast("CSV export ✔");
      });

      importFile.addEventListener("change", async (e) => {
        const file = e.target.files?.[0];
        if(!file) return;
        try{
          const text = await file.text();
          const json = JSON.parse(text);

          const incoming = Array.isArray(json) ? json : (json.entries || []);
          if(!Array.isArray(incoming)) throw new Error("Hibás formátum.");

          const cleaned = incoming.map(normalizeEntry).filter(Boolean);
          if(!cleaned.length) return showToast("Nincs importálható bejegyzés.");

          const map = new Map(entries.map(x => [x.id, x]));
          cleaned.forEach(x => map.set(x.id, x));
          entries = Array.from(map.values()).sort((a,b)=> new Date(b.ts)-new Date(a.ts));
          save(entries);

          if(json.chartPrefs) setChartPrefs(json.chartPrefs);
          if(json.uiPrefs) setUiPrefs(json.uiPrefs);

          showToast(`Import kész: ${cleaned.length} db ✔`);
          exitEditMode();
          page = 1;
          syncRangeCustomUI();
          render();
          markChangedAndMaybeSync();
        }catch(err){
          console.error(err);
          showToast("Import hiba.");
        }finally{
          importFile.value = "";
        }
      });

      clearAllBtn.addEventListener("click", () => {
        if(!confirm("Biztosan törlöd az összes bejegyzést?")) return;
        entries = [];
        save(entries);
        exitEditMode();
        page = 1;
        showToast("Minden törölve.");
        render();
        markChangedAndMaybeSync();
      });

      seedDemoBtn.addEventListener("click", () => {
        if(entries.length && !confirm("Már vannak adataid. Hozzáadjam a demo adatokat?")) return;
        const now = new Date();
        const demo = [];
        for(let i=0;i<22;i++){
          const d = new Date(now);
          d.setDate(d.getDate() - i);
          d.setHours(7 + (i%3)*2, 15, 0, 0);
          const baseSys = 116 + (i%6)*4;
          const baseDia = 74 + (i%5)*3;
          demo.push({
            id: cryptoRandomId(),
            ts: d.toISOString(),
            sys: baseSys + (i%2?2:-1),
            dia: baseDia + (i%2?1:0),
            pulse: 62 + (i%7)*3,
            note: i%3===0 ? "Reggel" : (i%4===0 ? "Kávé után" : ""),
            arm: i%2 ? "Bal" : "Jobb",
            context: i%5===0 ? "Terhelés után" : "Ülve"
          });
        }
        entries = [...demo, ...entries].sort((a,b)=> new Date(b.ts)-new Date(a.ts));
        save(entries);
        showToast("Demo adatok ✔");
        exitEditMode();
        page = 1;
        render();
        markChangedAndMaybeSync();
      });

      printBtn.addEventListener("click", async () => {
        await preparePrint();
        setTimeout(() => window.print(), 50);
      });

      window.addEventListener("resize", () => {
        if(chartVisible) drawChart(getFiltered().filtered);
      });

      // chart hover events
      chartCanvas.addEventListener("mouseleave", hideTooltip);
      chartCanvas.addEventListener("mousemove", (ev) => onPointerMove(ev.clientX, ev.clientY));
      chartCanvas.addEventListener("touchend", hideTooltip, {passive:true});
      chartCanvas.addEventListener("touchmove", (ev) => {
        if(!ev.touches || !ev.touches[0]) return;
        const t = ev.touches[0];
        onPointerMove(t.clientX, t.clientY);
      }, {passive:true});

      // cloud buttons
      syncSettingsBtn.addEventListener("click", async () => {
        await openSyncSettings();
      });
      syncNowBtn.addEventListener("click", async () => {
        await cloudSyncNow("manual");
      });

      /******************************************************************
       * Render
       ******************************************************************/
      function render(){
        const {filtered, total} = getFiltered();
        countLabel.textContent = `${total} bejegyzés`;
        filteredLabel.textContent = filtered.length === total ? "Szűrés: nincs" : `Szűrés: ${filtered.length}/${total}`;

        renderStats(filtered);

        if(chartVisible){
          chartHint.textContent = filtered.length ? `Megjelenített pontok: ${filtered.length}` : "Nincs adat a grafikonhoz";
          drawChart(filtered);
        }else{
          hideTooltip();
        }

        renderPager(filtered.length);
        renderListOnly();
      }

      function renderStats(arr){
        const n = arr.length;
        if(!n){
          avgSys.textContent = "–";
          avgDia.textContent = "–";
          avgPulse.textContent = "–";
          return;
        }
        const sSys = arr.reduce((a,b)=>a + (b.sys||0), 0);
        const sDia = arr.reduce((a,b)=>a + (b.dia||0), 0);
        const pulses = arr.map(x=>x.pulse).filter(v=>typeof v==="number" && isFinite(v));
        const sPulse = pulses.reduce((a,b)=>a+b,0);
        avgSys.textContent = Math.round(sSys/n);
        avgDia.textContent = Math.round(sDia/n);
        avgPulse.textContent = pulses.length ? Math.round(sPulse/pulses.length) : "–";
      }

      function renderListOnly(){
        const { filtered } = getFiltered();
        const paged = getPaged(filtered);

        list.innerHTML = "";
        if(!paged.items.length){
          empty.style.display = "block";
          return;
        }
        empty.style.display = "none";

        paged.items.forEach((e) => {
          const risk = classify(e.sys, e.dia);
          const alert = isAlert(e.sys, e.dia);

          const wrap = document.createElement("div");
          wrap.className = `item ${risk.className}`;

          const left = document.createElement("div");
          left.className = "l";

          const r1 = document.createElement("div");
          r1.className = "row";

          const b1 = badge(`SYS ${e.sys}`, risk.label);
          const b2 = badge(`DIA ${e.dia}`, "");
          const b3 = badge(e.pulse ? `Pulzus ${e.pulse}` : "Pulzus –", "");
          const t1 = tag(`${e.arm} kar`);
          const t2 = tag(e.context);

          r1.append(b1,b2,b3,t1,t2);

          if(alert){
            const a = document.createElement("span");
            a.className = "alertTag";
            a.textContent = "⚠ Riasztás";
            r1.appendChild(a);
          }

          const r2 = document.createElement("div");
          r2.className = "row";
          const when = document.createElement("div");
          when.className = "mini";
          when.textContent = formatHu(e.ts);
          r2.appendChild(when);

          left.append(r1,r2);

          if(e.note){
            const n = document.createElement("div");
            n.className = "note";
            n.textContent = e.note;
            left.appendChild(n);
          }

          const right = document.createElement("div");
          right.className = "r";

          const edit = document.createElement("button");
          edit.type="button";
          edit.className = "iconbtn";
          edit.textContent = "Szerkesztés";
          edit.addEventListener("click", () => enterEditMode(e));

          const del = document.createElement("button");
          del.type="button";
          del.className = "iconbtn d";
          del.textContent = "Törlés";
          del.addEventListener("click", () => {
            if(!confirm("Törlöd ezt a bejegyzést?")) return;
            entries = entries.filter(x => x.id !== e.id);
            save(entries);
            if(editingId === e.id) exitEditMode();

            const { filtered } = getFiltered();
            const { totalPages } = getPagingMeta(filtered.length);
            page = clampInt(page, 1, totalPages);

            showToast("Törölve.");
            render();
            markChangedAndMaybeSync();
          });

          const copy = document.createElement("button");
          copy.type="button";
          copy.className = "iconbtn";
          copy.textContent = "Másolás";
          copy.addEventListener("click", async () => {
            const text =
              `${formatHu(e.ts)} | ${e.context} | ${e.arm} kar | SYS ${e.sys} / DIA ${e.dia}` +
              (e.pulse?` | Pulzus ${e.pulse}`:"") +
              (e.note?` | ${e.note}`:"");
            try{
              await navigator.clipboard.writeText(text);
              showToast("Vágólapra ✔");
            }catch{
              showToast("Nem sikerült másolni.");
            }
          });

          right.append(copy, edit, del);
          wrap.append(left, right);
          list.appendChild(wrap);
        });
      }

      /******************************************************************
       * Lapozás
       ******************************************************************/
      function getPagingMeta(totalItems){
        const perPage = pageSize === Infinity ? (totalItems || 1) : pageSize;
        const totalPages = Math.max(1, Math.ceil(totalItems / perPage));
        return { perPage, totalPages };
      }

      function getPaged(filtered){
        const totalItems = filtered.length;
        const { perPage, totalPages } = getPagingMeta(totalItems);
        page = clampInt(page, 1, totalPages);

        if(pageSize === Infinity){
          return { items: filtered.slice(), totalItems, totalPages, page };
        }
        const start = (page - 1) * perPage;
        const end = start + perPage;
        return { items: filtered.slice(start, end), totalItems, totalPages, page };
      }

      function renderPager(totalItems){
        const { totalPages } = getPagingMeta(totalItems);
        pager.innerHTML = "";

        if(totalPages <= 1){
          pager.style.display = "none";
          return;
        }
        pager.style.display = "flex";

        const mkBtn = (label, onClick, opts={}) => {
          const b = document.createElement("button");
          b.type = "button";
          b.className = "pbtn";
          b.textContent = label;
          if(opts.title) b.title = opts.title;
          if(opts.disabled) b.disabled = true;
          if(opts.active) b.classList.add("active");
          b.addEventListener("click", onClick);
          return b;
        };

        pager.appendChild(mkBtn("⏮", () => { page = 1; renderListOnly(); renderPager(totalItems); }, { title:"Első", disabled: page===1 }));
        pager.appendChild(mkBtn("◀",  () => { page = Math.max(1, page-1); renderListOnly(); renderPager(totalItems); }, { title:"Előző", disabled: page===1 }));

        const pagesToShow = calcPageWindow(page, totalPages, 5);
        if(pagesToShow[0] > 1){
          pager.appendChild(mkBtn("1", () => { page=1; renderListOnly(); renderPager(totalItems); }, { active: page===1 }));
          if(pagesToShow[0] > 2){
            const dots = document.createElement("span");
            dots.className = "dots";
            dots.textContent = "…";
            pager.appendChild(dots);
          }
        }

        pagesToShow.forEach(pn => {
          pager.appendChild(mkBtn(String(pn), () => { page=pn; renderListOnly(); renderPager(totalItems); }, { active: page===pn }));
        });

        if(pagesToShow[pagesToShow.length-1] < totalPages){
          if(pagesToShow[pagesToShow.length-1] < totalPages-1){
            const dots = document.createElement("span");
            dots.className = "dots";
            dots.textContent = "…";
            pager.appendChild(dots);
          }
          pager.appendChild(mkBtn(String(totalPages), () => { page=totalPages; renderListOnly(); renderPager(totalItems); }, { active: page===totalPages }));
        }

        pager.appendChild(mkBtn("▶",  () => { page = Math.min(totalPages, page+1); renderListOnly(); renderPager(totalItems); }, { title:"Következő", disabled: page===totalPages }));
        pager.appendChild(mkBtn("⏭", () => { page = totalPages; renderListOnly(); renderPager(totalItems); }, { title:"Utolsó", disabled: page===totalPages }));
      }

      function calcPageWindow(current, total, windowSize){
        const w = Math.max(3, windowSize|0);
        let start = current - Math.floor(w/2);
        let end = start + w - 1;
        if(start < 1){ end += (1-start); start = 1; }
        if(end > total){ start -= (end-total); end = total; }
        start = Math.max(1, start);
        const out = [];
        for(let p=start; p<=end; p++) out.push(p);
        return out;
      }

      /******************************************************************
       * Szűrés
       ******************************************************************/
      function getFiltered(){
        const total = entries.length;
        const q = search.value.trim().toLowerCase();

        let days = null;
        if(range.value === "all") days = null;
        else if(range.value === "custom") days = clampInt(toInt(rangeCustomDays.value), 1, 3650);
        else days = toInt(range.value);

        const now = new Date();
        let filtered = entries.slice();

        if(days){
          const from = new Date(now);
          from.setDate(from.getDate() - days);
          filtered = filtered.filter(e => new Date(e.ts) >= from);
        }
        if(q){
          filtered = filtered.filter(e => (e.note||"").toLowerCase().includes(q));
        }

        filtered.sort((a,b)=> new Date(b.ts) - new Date(a.ts));
        return { filtered, total };
      }

      function syncRangeCustomUI(){
        rangeCustomWrap.style.display = (range.value === "custom") ? "inline-flex" : "none";
      }

      /******************************************************************
       * Szerkesztés
       ******************************************************************/
      function enterEditMode(e){
        editingId = e.id;
        formTitle.textContent = "Bejegyzés szerkesztése";
        saveBtn.textContent = "Módosítás mentése";
        cancelEditBtn.style.display = "inline-flex";

        dt.value = toDatetimeLocal(e.ts);
        sys.value = e.sys;
        dia.value = e.dia;
        pulse.value = (e.pulse ?? "");
        arm.value = e.arm;
        context.value = e.context;
        note.value = e.note || "";

        window.scrollTo({ top: 0, behavior: "smooth" });
        sys.focus();
        showToast("Szerkesztés ✔");
      }

      function exitEditMode(){
        editingId = null;
        formTitle.textContent = "Új mérés rögzítése";
        saveBtn.textContent = "Mentés";
        cancelEditBtn.style.display = "none";
        sys.value = "";
        dia.value = "";
        pulse.value = "";
        note.value = "";
      }

      function toDatetimeLocal(iso){
        const d = new Date(iso);
        const pad = (n)=>String(n).padStart(2,"0");
        return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
      }

      function setTimePreset(h, m){
        const base = dt.value ? new Date(dt.value) : new Date();
        const d = new Date(base);
        d.setHours(h, m, 0, 0);
        dt.value = toDatetimeLocal(d.toISOString());
      }

      function isAlert(sysV, diaV){
        return (sysV >= 140) || (diaV >= 90);
      }

      /******************************************************************
       * ✅ Grafikon (tengelyek: nap alul, érték bal oldalt)
       ******************************************************************/
      function drawChart(data){
        internalDrawChart(chartCanvas, data, 1, false);
      }

      function internalDrawChart(canvas, data, dprOverride, isPrint){
        const ctx = canvas.getContext("2d");
        const rect = canvas.getBoundingClientRect();
        const dpr = dprOverride || (window.devicePixelRatio || 1);

        // Resize backing store to match display size (for crisp lines)
        const cssW = Math.max(320, Math.round(rect.width));
        const cssH = Math.max(240, Math.round(rect.height));
        const targetW = Math.round(cssW * dpr);
        const targetH = Math.round(cssH * dpr);

        if(canvas.width !== targetW || canvas.height !== targetH){
          canvas.width = targetW;
          canvas.height = targetH;
        }

        // Clear
        ctx.setTransform(1,0,0,1,0,0);
        ctx.clearRect(0,0,canvas.width,canvas.height);

        // Theme for chart
        const bg = isPrint ? "#ffffff" : "rgba(0,0,0,.10)";
        const grid = isPrint ? "rgba(0,0,0,.12)" : "rgba(255,255,255,.10)";
        const axis = isPrint ? "rgba(0,0,0,.45)" : "rgba(255,255,255,.55)";
        const text = isPrint ? "#111" : "rgba(255,255,255,.82)";
        const textMuted = isPrint ? "rgba(0,0,0,.60)" : "rgba(255,255,255,.65)";
        const sysColor = "rgba(110,231,255,.95)";
        const diaColor = "rgba(167,139,250,.95)";
        const pulseColor = "rgba(62,230,160,.95)";
        const zoneFill = "rgba(255,204,102,.30)";
        const zoneStroke = "rgba(255,204,102,.85)";

        // Fill background
        ctx.fillStyle = bg;
        ctx.fillRect(0,0,canvas.width,canvas.height);

        const pad = { l: Math.round(62*dpr), r: Math.round(18*dpr), t: Math.round(18*dpr), b: Math.round(46*dpr) };
        const plot = {
          x: pad.l,
          y: pad.t,
          w: canvas.width - pad.l - pad.r,
          h: canvas.height - pad.t - pad.b
        };

        // No / not enough data
        if(!data || data.length === 0){
          ctx.fillStyle = textMuted;
          ctx.font = `${Math.round(14*dpr)}px Arial`;
          ctx.textAlign = "center";
          ctx.fillText("Nincs adat a grafikonhoz.", canvas.width/2, canvas.height/2);
          chartState = null;
          return;
        }

        // Sort by time ASC for chart
        const points = data.slice().sort((a,b)=> new Date(a.ts)-new Date(b.ts));

        // Determine y-range (include sys/dia; include pulse if visible)
        const vals = [];
        points.forEach(p=>{
          vals.push(p.sys, p.dia);
          if(showPulseChk.checked && typeof p.pulse === "number" && isFinite(p.pulse)) vals.push(p.pulse);
        });

        let yMin = Math.min(...vals);
        let yMax = Math.max(...vals);
        if(!isFinite(yMin) || !isFinite(yMax)){
          yMin = 0; yMax = 1;
        }

        // Expand a bit & "nice" axis
        const nice = niceBounds(yMin, yMax, 6);
        yMin = nice.min;
        yMax = nice.max;
        const yStep = nice.step;

        // x scale
        const xs = points.map((p,i)=>i);
        const xMin = 0;
        const xMax = Math.max(1, points.length-1);

        const xToPx = (x) => plot.x + (x - xMin) / (xMax - xMin) * plot.w;
        const yToPx = (y) => plot.y + (yMax - y) / (yMax - yMin) * plot.h;

        // Grid Y
        ctx.strokeStyle = grid;
        ctx.lineWidth = Math.max(1, 1*dpr);
        ctx.beginPath();
        for(let y=yMin; y<=yMax+0.0001; y+=yStep){
          const py = yToPx(y);
          ctx.moveTo(plot.x, py);
          ctx.lineTo(plot.x+plot.w, py);
        }
        ctx.stroke();

        // Grid X: show up to ~8 ticks
        const xTicks = chooseXTicks(points.length, 8);
        ctx.beginPath();
        xTicks.forEach(i=>{
          const px = xToPx(i);
          ctx.moveTo(px, plot.y);
          ctx.lineTo(px, plot.y+plot.h);
        });
        ctx.stroke();

        // Zone shading (SYS + DIA) - optional
        if(showZoneChk.checked){
          // We draw two bands combined visually by overlaying
          const zSysLo = clampInt(toInt(zoneSysLo.value), 60, 260);
          const zSysHi = clampInt(toInt(zoneSysHi.value), 60, 260);
          const zDiaLo = clampInt(toInt(zoneDiaLo.value), 40, 160);
          const zDiaHi = clampInt(toInt(zoneDiaHi.value), 40, 160);

          // SYS band
          const sysTop = yToPx(Math.max(zSysLo, zSysHi));
          const sysBot = yToPx(Math.min(zSysLo, zSysHi));
          ctx.fillStyle = zoneFill;
          ctx.fillRect(plot.x, sysTop, plot.w, sysBot - sysTop);

          // DIA band
          const diaTop = yToPx(Math.max(zDiaLo, zDiaHi));
          const diaBot = yToPx(Math.min(zDiaLo, zDiaHi));
          ctx.fillStyle = zoneFill;
          ctx.fillRect(plot.x, diaTop, plot.w, diaBot - diaTop);

          // Optional border hint on bands
          ctx.strokeStyle = zoneStroke;
          ctx.setLineDash([Math.round(6*dpr), Math.round(6*dpr)]);
          ctx.lineWidth = Math.max(1, 1*dpr);
          // SYS borders
          ctx.beginPath();
          ctx.moveTo(plot.x, sysTop); ctx.lineTo(plot.x+plot.w, sysTop);
          ctx.moveTo(plot.x, sysBot); ctx.lineTo(plot.x+plot.w, sysBot);
          // DIA borders
          ctx.moveTo(plot.x, diaTop); ctx.lineTo(plot.x+plot.w, diaTop);
          ctx.moveTo(plot.x, diaBot); ctx.lineTo(plot.x+plot.w, diaBot);
          ctx.stroke();
          ctx.setLineDash([]);
        }

        // Axes
        ctx.strokeStyle = axis;
        ctx.lineWidth = Math.max(1.2, 1.2*dpr);
        ctx.beginPath();
        // Y axis
        ctx.moveTo(plot.x, plot.y);
        ctx.lineTo(plot.x, plot.y+plot.h);
        // X axis
        ctx.moveTo(plot.x, plot.y+plot.h);
        ctx.lineTo(plot.x+plot.w, plot.y+plot.h);
        ctx.stroke();

        // Y labels (value) - left vertical axis
        ctx.fillStyle = textMuted;
        ctx.font = `${Math.round(12*dpr)}px Arial`;
        ctx.textAlign = "right";
        ctx.textBaseline = "middle";
        for(let y=yMin; y<=yMax+0.0001; y+=yStep){
          const py = yToPx(y);
          ctx.fillText(String(Math.round(y)), plot.x - Math.round(10*dpr), py);
        }

        // X labels (date) - bottom axis
        ctx.fillStyle = textMuted;
        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        xTicks.forEach(i=>{
          const px = xToPx(i);
          const label = formatDayShort(points[i].ts); // MM.DD
          ctx.fillText(label, px, plot.y+plot.h + Math.round(8*dpr));
        });

        // Axis title hints (small)
        ctx.fillStyle = textMuted;
        ctx.font = `${Math.round(11*dpr)}px Arial`;
        ctx.textAlign = "left";
        ctx.textBaseline = "top";
        ctx.fillText("Érték (mmHg/BPM)", plot.x, Math.round(2*dpr));
        ctx.textAlign = "right";
        ctx.fillText("Nap", plot.x+plot.w, plot.y+plot.h + Math.round(30*dpr));

        // Lines
        const drawSeries = (getY, color, showPoints=true) => {
          ctx.strokeStyle = color;
          ctx.lineWidth = Math.max(2, 2*dpr);
          ctx.beginPath();
          let started = false;
          points.forEach((p, i) => {
            const y = getY(p);
            if(y === null || !isFinite(y)) { started = false; return; }
            const x = xToPx(i);
            const py = yToPx(y);
            if(!started){
              ctx.moveTo(x, py);
              started = true;
            }else{
              ctx.lineTo(x, py);
            }
          });
          ctx.stroke();

          if(showPoints){
            ctx.fillStyle = color;
            points.forEach((p,i)=>{
              const y = getY(p);
              if(y === null || !isFinite(y)) return;
              const x = xToPx(i);
              const py = yToPx(y);
              ctx.beginPath();
              ctx.arc(x, py, Math.max(3, 3*dpr), 0, Math.PI*2);
              ctx.fill();
            });
          }
        };

        drawSeries(p=>p.sys, sysColor, true);
        drawSeries(p=>p.dia, diaColor, true);
        if(showPulseChk.checked){
          drawSeries(p=> (typeof p.pulse==="number" && isFinite(p.pulse)) ? p.pulse : null, pulseColor, true);
        }

        // Store hover state (for tooltip)
        chartState = {
          plot, dpr,
          points,
          xToPx, yToPx,
          sysColor, diaColor, pulseColor,
          hasPulse: !!showPulseChk.checked,
          yMin, yMax, xMin, xMax
        };

        // If currently visible tooltip and mouse still, it will update on next move
      }

      function niceBounds(min, max, ticks){
        if(min === max){
          min -= 1; max += 1;
        }
        const span = max - min;
        const rawStep = span / Math.max(2, ticks);
        const step = niceStep(rawStep);
        const niceMin = Math.floor(min/step) * step;
        const niceMax = Math.ceil(max/step) * step;
        return { min: niceMin, max: niceMax, step };
      }
      function niceStep(raw){
        const pow = Math.pow(10, Math.floor(Math.log10(raw)));
        const frac = raw / pow;
        let niceFrac;
        if(frac <= 1) niceFrac = 1;
        else if(frac <= 2) niceFrac = 2;
        else if(frac <= 5) niceFrac = 5;
        else niceFrac = 10;
        return niceFrac * pow;
      }
      function chooseXTicks(n, maxTicks){
        if(n <= 1) return [0];
        const ticks = Math.min(maxTicks, n);
        const step = Math.max(1, Math.round((n-1)/(ticks-1)));
        const out = [];
        for(let i=0; i<n; i+=step) out.push(i);
        if(out[out.length-1] !== n-1) out.push(n-1);
        return out;
      }

      function onPointerMove(clientX, clientY){
        if(!chartState) return;
        const rect = chartCanvas.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;
        const dpr = chartState.dpr || (window.devicePixelRatio || 1);

        const px = x * dpr;
        const py = y * dpr;

        const { plot, points } = chartState;
        if(px < plot.x || px > plot.x+plot.w || py < plot.y || py > plot.y+plot.h){
          hideTooltip();
          return;
        }

        // nearest x index
        const idx = nearestIndex(px, plot.x, plot.w, points.length);
        if(idx < 0 || idx >= points.length){ hideTooltip(); return; }

        const p = points[idx];

        // tooltip content
        const lines = [];
        lines.push({label:"SYS", val: p.sys, color: chartState.sysColor});
        lines.push({label:"DIA", val: p.dia, color: chartState.diaColor});
        if(chartState.hasPulse){
          lines.push({label:"Pulzus", val: (p.pulse ?? "–"), color: chartState.pulseColor});
        }

        // show tooltip
        const tHtml = `
          <div class="t">${escapeHtml(formatHu(p.ts))} • ${escapeHtml(p.context)} • ${escapeHtml(p.arm)} kar</div>
          <div class="row">
            ${lines.map(l => `
              <span class="b"><span class="s" style="background:${l.color}"></span>${escapeHtml(l.label)} ${escapeHtml(String(l.val))}</span>
            `).join("")}
          </div>
          ${p.note ? `<div class="t" style="margin-top:6px;color:rgba(255,255,255,.70)">${escapeHtml(p.note)}</div>` : ``}
        `;
        tooltip.innerHTML = tHtml;
        tooltip.style.display = "block";

        // position tooltip near cursor but keep in bounds
        const pad = 10;
        const tw = tooltip.offsetWidth || 260;
        const th = tooltip.offsetHeight || 80;
        let left = x + 12;
        let top = y + 12;

        if(left + tw + pad > rect.width) left = x - tw - 12;
        if(top + th + pad > rect.height) top = y - th - 12;
        left = Math.max(pad, Math.min(rect.width - tw - pad, left));
        top = Math.max(pad, Math.min(rect.height - th - pad, top));

        tooltip.style.left = left + "px";
        tooltip.style.top = top + "px";
      }

      function nearestIndex(px, plotX, plotW, n){
        if(n <= 1) return 0;
        const t = (px - plotX) / plotW;
        const idxFloat = t * (n - 1);
        if(snapNearestChk.checked){
          return Math.round(idxFloat);
        }
        // if not snap, still round (simpler)
        return Math.round(idxFloat);
      }

      function hideTooltip(){
        if(tooltip) tooltip.style.display = "none";
      }

      /******************************************************************
       * Print/PDF – grafikon rákerül, tengelyfeliratok + nap/érték is rajta
       ******************************************************************/
      async function preparePrint(){
        const { filtered } = getFiltered();
        const summary = computeSummary(filtered);
        const title = "Vérnyomásnapló – export";
        const now = new Date();

        const rangeLabel = getRangeLabel();
        const q = search.value.trim();

        const chartDataUrl = await buildPrintChartDataUrl(filtered, rangeLabel, q);

        const rowsHtml = filtered
          .slice()
          .sort((a,b)=> new Date(a.ts) - new Date(b.ts))
          .map(e => `
            <tr>
              <td>${escapeHtml(formatHu(e.ts))}</td>
              <td>${escapeHtml(e.context)}</td>
              <td>${escapeHtml(e.arm)}</td>
              <td><b>${escapeHtml(e.sys)}</b></td>
              <td><b>${escapeHtml(e.dia)}</b></td>
              <td>${escapeHtml(e.pulse ?? "")}</td>
              <td>${isAlert(e.sys,e.dia) ? "⚠ " : ""}${escapeHtml(e.note || "")}</td>
            </tr>
          `).join("");

        printArea.innerHTML = `
          <div class="printDoc">
            <div class="printHead">
              <div>
                <h2>${escapeHtml(title)}</h2>
                <div class="mutedPrint" style="font-size:12px; margin-top:4px;">
                  Szűrés: <b>${escapeHtml(rangeLabel)}</b>${q ? ` • Keresés: <b>${escapeHtml(q)}</b>` : ""} • Tételek: <b>${filtered.length}</b>
                </div>
              </div>
              <div class="printMeta">
                Generálva: <b>${escapeHtml(formatHu(now.toISOString()))}</b>
              </div>
            </div>

            <div class="printStats">
              <div class="pBox"><div class="mutedPrint">Átlag SYS</div><b>${summary.avgSys ?? "–"}</b> mmHg</div>
              <div class="pBox"><div class="mutedPrint">Átlag DIA</div><b>${summary.avgDia ?? "–"}</b> mmHg</div>
              <div class="pBox"><div class="mutedPrint">Átlag pulzus</div><b>${summary.avgPulse ?? "–"}</b> BPM</div>
              <div class="pBox"><div class="mutedPrint">Időszak</div><b>${escapeHtml(summary.period ?? "–")}</b></div>
            </div>

            <div class="printChartBox">
              ${chartDataUrl ? `<img src="${chartDataUrl}" alt="Grafikon" />` : `<div class="mutedPrint">Nincs elég adat a grafikonhoz.</div>`}
            </div>

            <table class="printTable">
              <thead>
                <tr>
                  <th>Dátum/idő</th>
                  <th>Helyzet</th>
                  <th>Kar</th>
                  <th>SYS</th>
                  <th>DIA</th>
                  <th>Pulzus</th>
                  <th>Megjegyzés</th>
                </tr>
              </thead>
              <tbody>
                ${rowsHtml || `<tr><td colspan="7">Nincs adat.</td></tr>`}
              </tbody>
            </table>

            <div class="mutedPrint" style="font-size:11px; margin-top:10px;">
              Megjegyzés: a napló információs célú; orvosi döntéshez egyeztess szakemberrel.
            </div>
          </div>
        `;
      }

      function getRangeLabel(){
        if(range.value === "all") return "Összes";
        if(range.value === "custom"){
          const d = clampInt(toInt(rangeCustomDays.value), 1, 3650);
          return `Utolsó ${d} nap (egyéni)`;
        }
        const days = toInt(range.value);
        return `Utolsó ${days} nap`;
      }

      function computeSummary(arr){
        if(!arr.length) return { avgSys:null, avgDia:null, avgPulse:null, period:null };
        const n = arr.length;
        const sSys = arr.reduce((a,b)=>a + (b.sys||0), 0);
        const sDia = arr.reduce((a,b)=>a + (b.dia||0), 0);
        const pulses = arr.map(x=>x.pulse).filter(v=>typeof v==="number" && isFinite(v));
        const sPulse = pulses.reduce((a,b)=>a+b,0);
        const sorted = arr.slice().sort((a,b)=> new Date(a.ts)-new Date(b.ts));
        const from = sorted[0].ts;
        const to = sorted[sorted.length-1].ts;
        return {
          avgSys: Math.round(sSys/n),
          avgDia: Math.round(sDia/n),
          avgPulse: pulses.length ? Math.round(sPulse/pulses.length) : null,
          period: `${formatShort(from)} – ${formatShort(to)}`
        };
      }

      async function buildPrintChartDataUrl(filtered, rangeLabel, q){
        if(!filtered || filtered.length < 1) return null;

        // Create chart-only canvas (print style)
        const chartOnly = document.createElement("canvas");
        chartOnly.width = 1400;
        chartOnly.height = 560;

        // Draw chart onto chartOnly in "print mode"
        internalDrawChartForPrint(chartOnly, filtered);

        // Compose final canvas with title + subtitle + chart + legend
        const out = document.createElement("canvas");
        out.width = 1400;
        out.height = 900;

        const ctx = out.getContext("2d");
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0,0,out.width,out.height);

        ctx.fillStyle = "#000";
        ctx.textAlign = "center";
        ctx.font = "bold 28px Arial";
        ctx.fillText("Vérnyomás trend grafikon", out.width/2, 44);

        ctx.font = "16px Arial";
        const sub = `${rangeLabel}${q ? " • Keresés: " + q : ""}`;
        ctx.fillText(sub, out.width/2, 72);

        // frame
        ctx.strokeStyle = "#bbbbbb";
        ctx.lineWidth = 2;
        ctx.strokeRect(12, 12, out.width-24, out.height-24);

        // chart image
        ctx.drawImage(chartOnly, 0, 110);

        // legend under chart
        const legendTop = 110 + 560 + 30;
        drawPrintLegend(ctx, 240, legendTop);

        try{ return out.toDataURL("image/png"); }catch{ return null; }
      }

      function internalDrawChartForPrint(canvas, data){
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0,0,canvas.width,canvas.height);

        // Temporarily force print-like rendering by calling internalDrawChart logic
        // We mimic the "display size" by setting a fake bounding box
        // Use a wrapper that doesn't rely on getBoundingClientRect.
        const dpr = 1;

        // We implement a simplified variant using the same drawing approach as internalDrawChart,
        // but fixed dimensions and print colors.
        const points = data.slice().sort((a,b)=> new Date(a.ts)-new Date(b.ts));

        const bg = "#ffffff";
        const grid = "rgba(0,0,0,.12)";
        const axis = "rgba(0,0,0,.45)";
        const textMuted = "rgba(0,0,0,.60)";
        const sysColor = "rgba(110,231,255,.95)";
        const diaColor = "rgba(167,139,250,.95)";
        const pulseColor = "rgba(62,230,160,.95)";
        const zoneFill = "rgba(255,204,102,.30)";
        const zoneStroke = "rgba(255,204,102,.85)";

        ctx.fillStyle = bg;
        ctx.fillRect(0,0,canvas.width,canvas.height);

        const pad = { l: 80, r: 20, t: 20, b: 60 };
        const plot = { x: pad.l, y: pad.t, w: canvas.width-pad.l-pad.r, h: canvas.height-pad.t-pad.b };

        const vals = [];
        points.forEach(p=>{
          vals.push(p.sys, p.dia);
          if(showPulseChk.checked && typeof p.pulse === "number" && isFinite(p.pulse)) vals.push(p.pulse);
        });
        let yMin = Math.min(...vals), yMax = Math.max(...vals);
        if(!isFinite(yMin)||!isFinite(yMax)){ yMin=0;yMax=1; }
        const nice = niceBounds(yMin, yMax, 6);
        yMin = nice.min; yMax = nice.max; const yStep = nice.step;

        const xMax = Math.max(1, points.length-1);
        const xToPx = (i)=> plot.x + (i/xMax)*plot.w;
        const yToPx = (y)=> plot.y + (yMax-y)/(yMax-yMin)*plot.h;

        // grid
        ctx.strokeStyle = grid;
        ctx.lineWidth = 1;
        ctx.beginPath();
        for(let y=yMin; y<=yMax+0.0001; y+=yStep){
          const py = yToPx(y);
          ctx.moveTo(plot.x, py); ctx.lineTo(plot.x+plot.w, py);
        }
        const xTicks = chooseXTicks(points.length, 8);
        xTicks.forEach(i=>{
          const px = xToPx(i);
          ctx.moveTo(px, plot.y); ctx.lineTo(px, plot.y+plot.h);
        });
        ctx.stroke();

        // zone
        if(showZoneChk.checked){
          const zSysLo = clampInt(toInt(zoneSysLo.value), 60, 260);
          const zSysHi = clampInt(toInt(zoneSysHi.value), 60, 260);
          const zDiaLo = clampInt(toInt(zoneDiaLo.value), 40, 160);
          const zDiaHi = clampInt(toInt(zoneDiaHi.value), 40, 160);

          const sysTop = yToPx(Math.max(zSysLo,zSysHi));
          const sysBot = yToPx(Math.min(zSysLo,zSysHi));
          ctx.fillStyle = zoneFill;
          ctx.fillRect(plot.x, sysTop, plot.w, sysBot-sysTop);

          const diaTop = yToPx(Math.max(zDiaLo,zDiaHi));
          const diaBot = yToPx(Math.min(zDiaLo,zDiaHi));
          ctx.fillStyle = zoneFill;
          ctx.fillRect(plot.x, diaTop, plot.w, diaBot-diaTop);

          ctx.strokeStyle = zoneStroke;
          ctx.setLineDash([6,6]);
          ctx.beginPath();
          ctx.moveTo(plot.x, sysTop); ctx.lineTo(plot.x+plot.w, sysTop);
          ctx.moveTo(plot.x, sysBot); ctx.lineTo(plot.x+plot.w, sysBot);
          ctx.moveTo(plot.x, diaTop); ctx.lineTo(plot.x+plot.w, diaTop);
          ctx.moveTo(plot.x, diaBot); ctx.lineTo(plot.x+plot.w, diaBot);
          ctx.stroke();
          ctx.setLineDash([]);
        }

        // axes
        ctx.strokeStyle = axis;
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.moveTo(plot.x, plot.y); ctx.lineTo(plot.x, plot.y+plot.h);
        ctx.moveTo(plot.x, plot.y+plot.h); ctx.lineTo(plot.x+plot.w, plot.y+plot.h);
        ctx.stroke();

        // labels
        ctx.fillStyle = textMuted;
        ctx.font = "12px Arial";
        ctx.textAlign = "right";
        ctx.textBaseline = "middle";
        for(let y=yMin; y<=yMax+0.0001; y+=yStep){
          ctx.fillText(String(Math.round(y)), plot.x-10, yToPx(y));
        }

        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        xTicks.forEach(i=>{
          ctx.fillText(formatDayShort(points[i].ts), xToPx(i), plot.y+plot.h+10);
        });

        ctx.font = "11px Arial";
        ctx.textAlign = "left";
        ctx.textBaseline = "top";
        ctx.fillText("Érték (mmHg/BPM)", plot.x, 2);
        ctx.textAlign = "right";
        ctx.fillText("Nap", plot.x+plot.w, plot.y+plot.h+34);

        const drawSeries = (getY, color) => {
          ctx.strokeStyle = color;
          ctx.lineWidth = 2;
          ctx.beginPath();
          let started=false;
          points.forEach((p,i)=>{
            const y=getY(p);
            if(y===null || !isFinite(y)){ started=false; return; }
            const px=xToPx(i), py=yToPx(y);
            if(!started){ ctx.moveTo(px,py); started=true; } else ctx.lineTo(px,py);
          });
          ctx.stroke();

          ctx.fillStyle = color;
          points.forEach((p,i)=>{
            const y=getY(p);
            if(y===null || !isFinite(y)) return;
            const px=xToPx(i), py=yToPx(y);
            ctx.beginPath();
            ctx.arc(px,py,3,0,Math.PI*2);
            ctx.fill();
          });
        };

        drawSeries(p=>p.sys, sysColor);
        drawSeries(p=>p.dia, diaColor);
        if(showPulseChk.checked){
          drawSeries(p=> (typeof p.pulse==="number" && isFinite(p.pulse)) ? p.pulse : null, pulseColor);
        }
      }

      function drawPrintLegend(ctx, xStart, y){
        const items = [
          { label: "SYS (mmHg)", color: "rgba(110,231,255,.95)", border:"#666" },
          { label: "DIA (mmHg)", color: "rgba(167,139,250,.95)", border:"#666" },
          { label: "Pulzus (BPM)", color: "rgba(62,230,160,.95)", border:"#666" },
          { label: "Célzóna", color: "rgba(255,204,102,.45)", border: "rgba(255,204,102,.85)" }
        ];

        ctx.save();
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "#111";
        ctx.font = "bold 16px Arial";
        ctx.fillText("Színmagyarázat:", xStart, y);

        ctx.font = "14px Arial";
        let x = xStart;
        let yy = y + 26;

        for(const it of items){
          ctx.fillStyle = it.color;
          ctx.fillRect(x, yy-8, 18, 18);
          ctx.strokeStyle = it.border || "#666";
          ctx.lineWidth = 1;
          ctx.strokeRect(x, yy-8, 18, 18);

          ctx.fillStyle = "#111";
          ctx.fillText(it.label, x + 26, yy + 1);

          x += 240;
          if(x > 1180){
            x = xStart;
            yy += 26;
          }
        }
        ctx.restore();
      }

      /******************************************************************
       * CSV
       ******************************************************************/
      function stamp(){ return new Date().toISOString().slice(0,10); }

      function buildCsv(arr){
        const BOM = "\uFEFF";
        const header = ["DatumIdo","SYS","DIA","Pulzus","Kar","Helyzet","Riasztas","Megjegyzes"];
        const rows = arr
          .slice()
          .sort((a,b)=> new Date(a.ts) - new Date(b.ts))
          .map(e => ([
            formatHu(e.ts),
            e.sys,
            e.dia,
            (e.pulse ?? ""),
            e.arm,
            e.context,
            isAlert(e.sys,e.dia) ? "Igen" : "Nem",
            (e.note || "")
          ].map(csvEscape).join(",")));

        return BOM + header.join(",") + "\n" + rows.join("\n");
      }
      function csvEscape(v){
        const s = String(v ?? "");
        if(/[",\n\r]/.test(s)) return `"${s.replace(/"/g,'""')}"`;
        return s;
      }

      function downloadBlob(text, filename, mime){
        const blob = new Blob([text], {type:mime});
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }

      /******************************************************************
       * Tárolás (local)
       ******************************************************************/
      function save(arr){ localStorage.setItem(STORAGE_KEY, JSON.stringify(arr)); }

      function loadAny(){
        const candidates = [STORAGE_KEY, "bp_log_v14", "bp_log_v13", "bp_log_v12", "bp_log_v11", "bp_log_v10", "bp_log_v9", "bp_log_v8", "bp_log_v7", "bp_log_v6", "bp_log_v5", "bp_log_v4", "bp_log_v3", "bp_log_v2", "bp_log_v1"];
        for(const key of candidates){
          try{
            const raw = localStorage.getItem(key);
            if(!raw) continue;
            const arr = JSON.parse(raw);
            const fixed = Array.isArray(arr) ? arr.map(normalizeEntry).filter(Boolean) : [];
            localStorage.setItem(STORAGE_KEY, JSON.stringify(fixed));
            return fixed;
          }catch{}
        }
        return [];
      }

      function normalizeEntry(e){
        try{
          if(!e) return null;
          const id = String(e.id || cryptoRandomId());
          const ts = new Date(e.ts || e.date || Date.now()).toISOString();
          const sys = toInt(e.sys);
          const dia = toInt(e.dia);
          const pulse = (e.pulse===null || e.pulse===undefined || e.pulse==="") ? null : toInt(e.pulse);
          if(!isFinite(sys) || !isFinite(dia)) return null;
          return {
            id, ts, sys, dia,
            pulse: (pulse && isFinite(pulse)) ? pulse : null,
            note: String(e.note || "").trim(),
            arm: (e.arm === "Jobb" || e.arm === "Bal") ? e.arm : "Bal",
            context: String(e.context || "Ülve")
          };
        }catch{
          return null;
        }
      }

      /******************************************************************
       * UI Prefs
       ******************************************************************/
      function getUiPrefs(){
        return {
          pageSize: pageSize === Infinity ? "all" : String(pageSize),
          range: range.value,
          rangeCustomDays: String(clampInt(toInt(rangeCustomDays.value), 1, 3650) || 14)
        };
      }
      function setUiPrefs(p){
        if(!p) return;

        const ps = (p.pageSize ?? "5");
        pageSizeSel.value = String(ps);
        pageSize = (String(ps) === "all") ? Infinity : clampInt(toInt(ps), 1, 9999);

        const rv = String(p.range ?? "all");
        range.value = ["all","7","30","custom"].includes(rv) ? rv : "all";
        const cd = clampInt(toInt(p.rangeCustomDays ?? "14"), 1, 3650);
        rangeCustomDays.value = String(cd);

        syncRangeCustomUI();
        saveUiPrefs();
      }
      function saveUiPrefs(){
        try{ localStorage.setItem(UI_KEY, JSON.stringify(getUiPrefs())); }catch{}
      }
      function loadUiPrefs(){
        try{
          const raw = localStorage.getItem(UI_KEY);
          if(!raw){
            pageSizeSel.value = "5"; pageSize = 5;
            return;
          }
          setUiPrefs(JSON.parse(raw));
        }catch{
          pageSizeSel.value = "5"; pageSize = 5;
        }
      }

      /******************************************************************
       * Chart prefs
       ******************************************************************/
      function getChartPrefs(){
        return {
          showPulse: !!showPulseChk.checked,
          showZone: !!showZoneChk.checked,
          snapNearest: !!snapNearestChk.checked,
          zoneSysLo: toInt(zoneSysLo.value),
          zoneSysHi: toInt(zoneSysHi.value),
          zoneDiaLo: toInt(zoneDiaLo.value),
          zoneDiaHi: toInt(zoneDiaHi.value),
        };
      }
      function setChartPrefs(p){
        try{
          if(p.showPulse !== undefined) showPulseChk.checked = !!p.showPulse;
          if(p.showZone !== undefined) showZoneChk.checked = !!p.showZone;
          if(p.snapNearest !== undefined) snapNearestChk.checked = !!p.snapNearest;

          if(isFinite(toInt(p.zoneSysLo))) zoneSysLo.value = String(toInt(p.zoneSysLo));
          if(isFinite(toInt(p.zoneSysHi))) zoneSysHi.value = String(toInt(p.zoneSysHi));
          if(isFinite(toInt(p.zoneDiaLo))) zoneDiaLo.value = String(toInt(p.zoneDiaLo));
          if(isFinite(toInt(p.zoneDiaHi))) zoneDiaHi.value = String(toInt(p.zoneDiaHi));

          persistChartPrefs();
        }catch{}
      }
      function persistChartPrefs(){
        try{ localStorage.setItem(PREF_KEY, JSON.stringify(getChartPrefs())); }catch{}
      }
      function loadChartPrefs(){
        try{
          const raw = localStorage.getItem(PREF_KEY);
          if(!raw) return;
          setChartPrefs(JSON.parse(raw));
        }catch{}
      }

      /******************************************************************
       * Segédfüggvények
       ******************************************************************/
      function setNow(show=false){
        const d = new Date();
        const pad = (n)=>String(n).padStart(2,"0");
        dt.value = `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
        if(show) showToast("Idő ✔");
      }

      function toInt(v){
        const n = parseInt(String(v).trim(), 10);
        return Number.isFinite(n) ? n : NaN;
      }
      function clampInt(v, lo, hi){
        const n = parseInt(v,10);
        if(!Number.isFinite(n)) return lo;
        return Math.max(lo, Math.min(hi, n));
      }

      function showToast(msg){
        toast.textContent = msg;
        toast.style.display = "block";
        clearTimeout(showToast._t);
        showToast._t = setTimeout(()=> toast.style.display="none", 2200);
      }

      function cryptoRandomId(){
        const a = new Uint32Array(2);
        (crypto?.getRandomValues ? crypto.getRandomValues(a) : (a[0]=Math.random()*2**32, a[1]=Math.random()*2**32));
        return "bp_" + a[0].toString(16).padStart(8,"0") + a[1].toString(16).padStart(8,"0");
      }

      function formatHu(iso){
        const d = new Date(iso);
        const pad = (n)=>String(n).padStart(2,"0");
        return `${d.getFullYear()}.${pad(d.getMonth()+1)}.${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
      }
      function formatShort(iso){
        const d = new Date(iso);
        const pad = (n)=>String(n).padStart(2,"0");
        return `${d.getFullYear()}.${pad(d.getMonth()+1)}.${pad(d.getDate())}`;
      }
      function formatDayShort(iso){
        const d = new Date(iso);
        const pad = (n)=>String(n).padStart(2,"0");
        return `${pad(d.getMonth()+1)}.${pad(d.getDate())}`;
      }

      function escapeHtml(s){
        return String(s ?? "")
          .replaceAll("&","&amp;")
          .replaceAll("<","&lt;")
          .replaceAll(">","&gt;")
          .replaceAll('"',"&quot;")
          .replaceAll("'","&#039;");
      }

      function classify(sys, dia){
        if(sys < 130 && dia < 85) return { className:"risk-ok", label:"OK" };
        if(sys < 140 && dia < 90) return { className:"risk-warn", label:"Emelkedett" };
        return { className:"risk-high", label:"Magas" };
      }

      function badge(text, hint){
        const el = document.createElement("span");
        el.className = "badge";
        el.textContent = text;
        if(hint){
          const h = document.createElement("span");
          h.className="tag";
          h.textContent = hint;
          el.appendChild(h);
        }
        return el;
      }
      function tag(text){
        const el = document.createElement("span");
        el.className = "tag";
        el.textContent = text;
        return el;
      }

      /******************************************************************
       * ✅ Export objektum (felhőbe is ez megy titkosítva)
       ******************************************************************/
      function buildExportObject(){
        return {
          exportedAt: new Date().toISOString(),
          version: 15,
          entries,
          chartPrefs: getChartPrefs(),
          uiPrefs: getUiPrefs(),
          localRevision
        };
      }

      /******************************************************************
       * ✅ FELHŐ SZINKRON – Supabase + AES-GCM titkosítás
       ******************************************************************/
      function initSupabase(){
        try{
          if(!window.supabase || !window.supabase.createClient) throw new Error("Supabase SDK nem töltött be");
          sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        }catch(err){
          console.error(err);
          sb = null;
        }
      }

      function loadSyncCfg(){
        try{
          const raw = localStorage.getItem(SYNC_KEY);
          if(!raw) return { enabled:false, logId:"", pinHint:"", lastPullAt:null, lastPushAt:null, lastRemoteAt:null };
          const j = JSON.parse(raw);
          return {
            enabled: !!j.enabled,
            logId: String(j.logId||""),
            pinHint: String(j.pinHint||""),
            lastPullAt: j.lastPullAt || null,
            lastPushAt: j.lastPushAt || null,
            lastRemoteAt: j.lastRemoteAt || null
          };
        }catch{
          return { enabled:false, logId:"", pinHint:"", lastPullAt:null, lastPushAt:null, lastRemoteAt:null };
        }
      }
      function saveSyncCfg(){
        try{ localStorage.setItem(SYNC_KEY, JSON.stringify(syncCfg)); }catch{}
        updateSyncUI("cfg");
      }

      function updateSyncUI(){
        if(!sb){
          syncText.textContent = "Felhő szinkron: Supabase hiba";
          syncDot.className = "syncDot bad";
          syncMeta.textContent = "—";
          return;
        }

        if(!syncCfg.enabled || !syncCfg.logId){
          syncText.textContent = "Felhő szinkron: kikapcsolva";
          syncDot.className = "syncDot";
          syncMeta.textContent = "—";
          return;
        }

        if(!crypto?.subtle){
          syncText.textContent = "Felhő szinkron: HTTPS szükséges (titkosításhoz)";
          syncDot.className = "syncDot bad";
          syncMeta.textContent = "A WebCrypto nem elérhető.";
          return;
        }

        if(syncBusy){
          syncText.textContent = "Felhő szinkron: folyamatban…";
          syncDot.className = "syncDot mid";
        }else{
          syncText.textContent = "Felhő szinkron: aktív";
          syncDot.className = "syncDot ok";
        }

        const pull = syncCfg.lastPullAt ? formatHu(syncCfg.lastPullAt) : "—";
        const push = syncCfg.lastPushAt ? formatHu(syncCfg.lastPushAt) : "—";
        syncMeta.textContent = `Letöltés: ${pull} • Feltöltés: ${push}`;
      }

      async function openSyncSettings(){
        if(!sb){
          showToast("Supabase nem elérhető.");
          return;
        }
        if(!crypto?.subtle){
          alert("A felhő szinkron titkosítást használ (WebCrypto).\nEhhez HTTPS/secure környezet kell.\n\nTedd HTTPS alá az oldalt (pl. Pages, tárhely SSL).");
          return;
        }

        const ok = confirm("Felhő szinkron beállítás:\n\nOK = bekapcsolom / módosítom\nMégse = kilép");
        if(!ok) return;

        const logId = prompt("Napló azonosító (pl. csalad_bp vagy egyedi kód):", syncCfg.logId || "");
        if(!logId) return;

        const pin = prompt("PIN/Jelszó (ezzel titkosítjuk, ugyanaz kell minden eszközön):", "");
        if(!pin) return;

        const pinHint = prompt("PIN emlékeztető (opcionális, csak helyben látszik):", syncCfg.pinHint || "") || "";

        syncCfg.enabled = true;
        syncCfg.logId = logId.trim();
        syncCfg.pinHint = pinHint.trim();
        saveSyncCfg();

        await cloudSyncNow("settings", pin);
      }

      function markChangedAndMaybeSync(){
        localRevision = Date.now();
        if(syncCfg.enabled && syncCfg.logId && sb){
          scheduleCloudPush();
        }
      }

      function scheduleCloudPush(){
        clearTimeout(syncDebounceT);
        syncDebounceT = setTimeout(async () => {
          await cloudPush({reason:"debounced"});
        }, 900);
      }

      async function cloudSyncNow(reason, pinMaybe){
        await cloudPull({reason});
        await cloudPush({reason, pinOverride: pinMaybe || null});
      }

      async function cloudPull(){
        if(!sb || !syncCfg.enabled || !syncCfg.logId) return;

        const pin = await getPinForSync();
        if(!pin) return;

        syncBusy = true; updateSyncUI();
        try{
          const { data, error } = await sb
            .from(SUPABASE_TABLE)
            .select("id, updated_at, payload")
            .eq("id", syncCfg.logId)
            .maybeSingle();

          if(error) throw error;
          if(!data){
            syncCfg.lastPullAt = new Date().toISOString();
            saveSyncCfg();
            return;
          }

          syncCfg.lastRemoteAt = data.updated_at;
          const remoteObj = await decryptPayloadToObject(data.payload, pin);

          const remoteRev = Number(remoteObj?.localRevision || 0);
          const remoteNewer = remoteRev > (localRevision || 0);

          if(remoteNewer){
            if(Array.isArray(remoteObj.entries)){
              entries = remoteObj.entries.map(normalizeEntry).filter(Boolean).sort((a,b)=> new Date(b.ts)-new Date(a.ts));
              save(entries);
            }
            if(remoteObj.chartPrefs) setChartPrefs(remoteObj.chartPrefs);
            if(remoteObj.uiPrefs) setUiPrefs(remoteObj.uiPrefs);
            localRevision = remoteRev || Date.now();
            showToast("Felhőből frissítve ✔");
            page = 1;
            render();
          }

          syncCfg.lastPullAt = new Date().toISOString();
          saveSyncCfg();
        }catch(err){
          console.error(err);
          showToast("Felhő letöltés hiba.");
        }finally{
          syncBusy = false; updateSyncUI();
        }
      }

      async function cloudPush({pinOverride=null}){
        if(!sb || !syncCfg.enabled || !syncCfg.logId) return;

        const pin = pinOverride || await getPinForSync();
        if(!pin) return;

        syncBusy = true; updateSyncUI();
        try{
          const obj = buildExportObject();
          const payload = await encryptObjectToPayload(obj, pin);

          const nowIso = new Date().toISOString();
          const { error } = await sb
            .from(SUPABASE_TABLE)
            .upsert({ id: syncCfg.logId, payload, updated_at: nowIso }, { onConflict: "id" });

          if(error) throw error;

          syncCfg.lastPushAt = nowIso;
          syncCfg.lastRemoteAt = nowIso;
          saveSyncCfg();
        }catch(err){
          console.error(err);
          showToast("Felhő feltöltés hiba.");
        }finally{
          syncBusy = false; updateSyncUI();
        }
      }

      async function getPinForSync(){
        const hint = syncCfg.pinHint ? `\n(Emlékeztető: ${syncCfg.pinHint})` : "";
        const pin = prompt(`Felhő szinkron PIN/Jelszó szükséges.${hint}`, "");
        return (pin || "").trim() || null;
      }

      async function deriveKey(pin, saltStr){
        const enc = new TextEncoder();
        const salt = enc.encode(saltStr);

        const baseKey = await crypto.subtle.importKey(
          "raw",
          enc.encode(pin),
          { name: "PBKDF2" },
          false,
          ["deriveKey"]
        );

        return crypto.subtle.deriveKey(
          {
            name: "PBKDF2",
            salt,
            iterations: 120000,
            hash: "SHA-256",
          },
          baseKey,
          { name: "AES-GCM", length: 256 },
          false,
          ["encrypt","decrypt"]
        );
      }

      function b64FromBytes(bytes){
        let s = "";
        bytes.forEach(b => s += String.fromCharCode(b));
        return btoa(s);
      }
      function bytesFromB64(b64){
        const bin = atob(b64);
        const bytes = new Uint8Array(bin.length);
        for(let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i);
        return bytes;
      }

      async function encryptObjectToPayload(obj, pin){
        const saltStr = `bp:${syncCfg.logId}:v2`;
        const key = await deriveKey(pin, saltStr);

        const iv = crypto.getRandomValues(new Uint8Array(12));
        const enc = new TextEncoder();
        const plain = enc.encode(JSON.stringify(obj));

        const cipherBuf = await crypto.subtle.encrypt(
          { name: "AES-GCM", iv },
          key,
          plain
        );

        const cipher = new Uint8Array(cipherBuf);
        return "v2." + b64FromBytes(iv) + "." + b64FromBytes(cipher);
      }

      async function decryptPayloadToObject(payload, pin){
        if(!payload || typeof payload !== "string") throw new Error("payload üres");
        const parts = payload.split(".");
        if(parts.length !== 3) throw new Error("payload formátum hibás");
        const ver = parts[0];

        const iv = bytesFromB64(parts[1]);
        const cipher = bytesFromB64(parts[2]);

        // accept v1 or v2
        const saltStr = `bp:${syncCfg.logId}:${ver}`;
        const key = await deriveKey(pin, saltStr);

        const plainBuf = await crypto.subtle.decrypt(
          { name: "AES-GCM", iv },
          key,
          cipher
        );

        const dec = new TextDecoder();
        const json = dec.decode(plainBuf);
        return JSON.parse(json);
      }

      /******************************************************************
       * Kockázat
       ******************************************************************/
      function isFinite(n){ return Number.isFinite(n); }

      /******************************************************************
       * Print legend helper & UI
       ******************************************************************/
      // (already above)

      /******************************************************************
       * Export object already above
       ******************************************************************/

      /******************************************************************
       * Print helpers
       ******************************************************************/
      function escapeHtmlPrint(s){ return escapeHtml(s); }

      /******************************************************************
       * Risk helpers
       ******************************************************************/
      // (already above)

      /******************************************************************
       * Build / save UI prefs
       ******************************************************************/
      // (already above)

      /******************************************************************
       * Print: short helpers already
       ******************************************************************/

      /******************************************************************
       * Add missing helpers used by print build
       ******************************************************************/
      function getRangeLabel(){ return (function(){
        if(range.value === "all") return "Összes";
        if(range.value === "custom"){
          const d = clampInt(toInt(rangeCustomDays.value), 1, 3650);
          return `Utolsó ${d} nap (egyéni)`;
        }
        const days = toInt(range.value);
        return `Utolsó ${days} nap`;
      })(); }

      /******************************************************************
       * Additional: keep chart state updated on initial render
       ******************************************************************/
      // already handled by render()

      /******************************************************************
       * (End)
       ******************************************************************/
    })();
  </script>
</body>
</html>